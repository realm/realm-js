{"version":3,"file":"OrderedCollection.js","sourceRoot":"","sources":["OrderedCollection.ts"],"names":[],"mappings":"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","sourcesContent":["////////////////////////////////////////////////////////////////////////////\n//\n// Copyright 2022 Realm Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n////////////////////////////////////////////////////////////////////////////\n\nimport {\n  ClassHelpers,\n  Collection,\n  DefaultObject,\n  INTERNAL,\n  IllegalConstructorError,\n  JSONCacheMap,\n  Realm,\n  RealmObject,\n  Results,\n  TypeAssertionError,\n  TypeHelpers,\n  assert,\n  binding,\n  getTypeName,\n  mixedToBinding,\n  unwind,\n} from \"./internal\";\n\nconst DEFAULT_COLUMN_KEY = 0n as unknown as binding.ColKey;\n\ntype PropertyType = string;\nexport type SortDescriptor = string | [string, boolean];\n\nexport type CollectionChangeSet = {\n  insertions: number[];\n  deletions: number[];\n  newModifications: number[];\n  oldModifications: number[];\n};\nexport type CollectionChangeCallback<T = unknown, EntryType extends [unknown, unknown] = [unknown, unknown]> = (\n  collection: OrderedCollection<T, EntryType>,\n  changes: CollectionChangeSet,\n) => void;\n\n/** @internal */\nexport type OrderedCollectionHelpers = TypeHelpers & {\n  get(results: binding.Results, index: number): unknown;\n};\n\nconst DEFAULT_PROPERTY_DESCRIPTOR: PropertyDescriptor = { configurable: true, enumerable: true, writable: true };\nconst PROXY_HANDLER: ProxyHandler<OrderedCollection> = {\n  // TODO: Consider executing the `parseInt` first to optimize for index access over accessing a member on the list\n  get(target, prop) {\n    if (Reflect.has(target, prop)) {\n      return Reflect.get(target, prop);\n    } else if (typeof prop === \"string\") {\n      const index = Number.parseInt(prop, 10);\n      // TODO: Consider catching an error from access out of bounds, instead of checking the length, to optimize for the hot path\n      if (!Number.isNaN(index) && index >= 0 && index < target.length) {\n        return target.get(index);\n      }\n    }\n  },\n  set(target, prop, value, receiver) {\n    if (typeof prop === \"string\") {\n      const index = Number.parseInt(prop, 10);\n      // TODO: Consider catching an error from access out of bounds, instead of checking the length, to optimize for the hot path\n      // TODO: Do we expect an upper bound check on the index when setting?\n      if (!Number.isNaN(index) && index >= 0) {\n        target.set(index, value);\n        return true;\n      } else if (index < 0) {\n        throw new Error(`Index ${index} cannot be less than zero.`);\n      }\n    }\n    return Reflect.set(target, prop, value, receiver);\n  },\n  ownKeys(target) {\n    return Reflect.ownKeys(target).concat([...target.keys()].map(String));\n  },\n  getOwnPropertyDescriptor(target, prop) {\n    if (Reflect.has(target, prop)) {\n      return Reflect.getOwnPropertyDescriptor(target, prop);\n    } else if (typeof prop === \"string\") {\n      const index = Number.parseInt(prop, 10);\n      if (index < target.length) {\n        return DEFAULT_PROPERTY_DESCRIPTOR;\n      }\n    }\n  },\n};\n\nexport abstract class OrderedCollection<T = unknown, EntryType extends [unknown, unknown] = [number, T]>\n  extends Collection<number, T, EntryType, T, CollectionChangeCallback<T, EntryType>>\n  implements Omit<ReadonlyArray<T>, \"entries\">\n{\n  /** @internal */\n  constructor(\n    /** @internal */ protected realm: Realm,\n    /** @internal */ protected results: binding.Results,\n    /** @internal */ protected helpers: OrderedCollectionHelpers,\n  ) {\n    if (arguments.length === 0) {\n      throw new IllegalConstructorError(\"OrderedCollection\");\n    }\n    super((callback) => {\n      return this.results.addNotificationCallback((changes) => {\n        try {\n          callback(proxied, {\n            deletions: unwind(changes.deletions),\n            insertions: unwind(changes.insertions),\n            oldModifications: unwind(changes.modifications),\n            newModifications: unwind(changes.modificationsNew),\n          });\n        } catch (err) {\n          // Scheduling a throw on the event loop,\n          // since throwing synchroniously here would result in an abort in the calling C++\n          setImmediate(() => {\n            throw err;\n          });\n        }\n      }, []);\n    });\n    // Wrap in a proxy to trap ownKeys and get, enabling the spread operator\n    const proxied = new Proxy(this, PROXY_HANDLER as ProxyHandler<this>);\n    // Get the class helpers for later use, if available\n    const { objectType } = results;\n    if (typeof objectType === \"string\" && objectType !== \"\") {\n      this.classHelpers = this.realm.getClassHelpers(objectType);\n    } else {\n      this.classHelpers = null;\n    }\n    this.mixedToBinding = mixedToBinding.bind(undefined, realm.internal);\n    // Make the internal properties non-enumerable\n    Object.defineProperties(this, {\n      realm: {\n        enumerable: false,\n        configurable: false,\n        writable: false,\n      },\n      results: {\n        enumerable: false,\n        configurable: false,\n        writable: false,\n      },\n      helpers: {\n        enumerable: false,\n        configurable: false,\n        writable: false,\n      },\n      classHelpers: {\n        enumerable: false,\n        configurable: false,\n        writable: false,\n      },\n      mixedToBinding: {\n        enumerable: false,\n        configurable: false,\n        writable: false,\n      },\n    });\n    return proxied;\n  }\n\n  /** @internal */\n  protected classHelpers: ClassHelpers | null;\n  private mixedToBinding: (value: unknown) => binding.MixedArg;\n\n  /**\n   * Get an element of the ordered collection by index\n   * @param index The index\n   * @returns The element\n   * @internal\n   */\n  public get(index: number): T {\n    return this.helpers.fromBinding(this.helpers.get(this.results, index)) as T;\n  }\n\n  /**\n   * Set an element of the ordered collection by index\n   * @param index The index\n   * @param value The value\n   * @internal\n   */\n  public set(index: number, value: unknown) {\n    throw new Error(`Assigning into a ${this.constructor.name} is not support`);\n  }\n\n  /**\n   * The plain array representation of the collection for JSON serialization.\n   * Use circular JSON serialization libraries such as {@link https://www.npmjs.com/package/@ungap/structured-clone @ungap/structured-clone}\n   * and {@link https://www.npmjs.com/package/flatted flatted} for stringifying Realm entities that have circular structures.\n   * @returns An array of plain objects.\n   **/\n  toJSON(_?: string, cache?: unknown): Array<DefaultObject>;\n  /**\n   * @internal\n   */\n  toJSON(_?: string, cache = new JSONCacheMap()): Array<DefaultObject> {\n    return this.map((item, index) => {\n      if (item instanceof RealmObject) {\n        return item.toJSON(index.toString(), cache);\n      } else {\n        return item as DefaultObject;\n      }\n    });\n  }\n\n  *keys() {\n    const size = this.results.size();\n    for (let i = 0; i < size; i++) {\n      yield i;\n    }\n  }\n\n  *values() {\n    const snapshot = this.results.snapshot();\n    const { get, fromBinding } = this.helpers;\n    for (const i of this.keys()) {\n      yield fromBinding(get(snapshot, i)) as T;\n    }\n  }\n\n  *entries() {\n    const { get, fromBinding } = this.helpers;\n    const snapshot = this.results.snapshot();\n    const size = snapshot.size();\n    for (let i = 0; i < size; i++) {\n      yield [i, fromBinding(get(snapshot, i))] as EntryType;\n    }\n  }\n\n  readonly [n: number]: T;\n\n  get length(): number {\n    return this.results.size();\n  }\n\n  get type(): PropertyType {\n    return getTypeName(this.results.type & ~binding.PropertyType.Flags, undefined);\n  }\n\n  /**\n   * Whether `null` is a valid value for the collection.\n   * @readonly\n   * @since 2.0.0\n   */\n  get optional(): boolean {\n    return !!(this.results.type & binding.PropertyType.Nullable);\n  }\n\n  toString(): string {\n    return [...this].toString();\n  }\n  toLocaleString(): string {\n    return [...this].toLocaleString();\n  }\n  concat(...items: ConcatArray<T>[]): T[];\n  concat(...items: (T | ConcatArray<T>)[]): T[];\n  concat(...items: any[]): T[] {\n    return [...this].concat(...items);\n  }\n  join(separator?: string): string {\n    return [...this].join(separator);\n  }\n  slice(start?: number, end?: number): T[] {\n    return [...this].slice(start, end);\n  }\n  indexOf(searchElement: T, fromIndex?: number): number {\n    assert(typeof fromIndex === \"undefined\", \"The second fromIndex argument is not yet supported\");\n    if (this.type === \"object\") {\n      assert.instanceOf(searchElement, RealmObject);\n      return this.results.indexOfObj(searchElement[INTERNAL]);\n    } else {\n      return this.results.indexOf(this.helpers.toBinding(searchElement, undefined));\n    }\n  }\n  lastIndexOf(searchElement: T, fromIndex?: number): number {\n    return [...this].lastIndexOf(searchElement, fromIndex);\n  }\n  every<S extends T>(\n    predicate: (value: T, index: number, array: readonly T[]) => value is S,\n    thisArg?: any,\n  ): this is readonly S[];\n  every(predicate: (value: T, index: number, array: readonly T[]) => unknown, thisArg?: any): boolean;\n  every(predicate: any, thisArg?: any): boolean {\n    return [...this].every(predicate, thisArg);\n  }\n  some(predicate: (value: T, index: number, array: readonly T[]) => unknown, thisArg?: any): boolean {\n    return [...this].some(predicate, thisArg);\n  }\n  forEach(callbackfn: (value: T, index: number, array: readonly T[]) => void, thisArg?: any): void {\n    return [...this].forEach(callbackfn, thisArg);\n  }\n  map<U>(callbackfn: (value: T, index: number, array: readonly T[]) => U, thisArg?: any): U[] {\n    return [...this].map(callbackfn, thisArg);\n  }\n  filter<S extends T>(predicate: (value: T, index: number, array: readonly T[]) => value is S, thisArg?: any): S[];\n  filter(predicate: (value: T, index: number, array: readonly T[]) => unknown, thisArg?: any): T[];\n  filter<S extends T>(predicate: any, thisArg?: any): T[] | S[] {\n    return [...this].filter(predicate, thisArg);\n  }\n  reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: readonly T[]) => T): T;\n  reduce(\n    callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: readonly T[]) => T,\n    initialValue: T,\n  ): T;\n  reduce<U>(\n    callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: readonly T[]) => U,\n    initialValue: U,\n  ): U;\n  reduce<U>(callbackfn: any, initialValue?: any): T | U {\n    return [...this].reduce(callbackfn, initialValue);\n  }\n  reduceRight(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: readonly T[]) => T): T;\n  reduceRight(\n    callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: readonly T[]) => T,\n    initialValue: T,\n  ): T;\n  reduceRight<U>(\n    callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: readonly T[]) => U,\n    initialValue: U,\n  ): U;\n  reduceRight<U>(callbackfn: any, initialValue?: any): T | U {\n    return [...this].reduceRight(callbackfn, initialValue);\n  }\n\n  find<S extends T>(\n    predicate: (this: void, value: T, index: number, obj: T[]) => value is S,\n    thisArg?: any,\n  ): S | undefined;\n  find<T>(predicate: (value: T, index: number, obj: T[]) => unknown, thisArg?: any): T | undefined;\n  find(predicate: (value: T, index: number, obj: T[]) => boolean, thisArg?: any): T | undefined {\n    return [...this].find(predicate, thisArg);\n  }\n  findIndex(predicate: (value: T, index: number, obj: readonly T[]) => unknown, thisArg?: any): number {\n    return [...this].findIndex(predicate, thisArg);\n  }\n  // TODO: Implement support for RealmObjects, by comparing their #objectKey values\n  includes(searchElement: T, fromIndex?: number): boolean {\n    return this.indexOf(searchElement, fromIndex) !== -1;\n  }\n  flatMap<U, This = undefined>(\n    callback: (this: This, value: T, index: number, array: T[]) => U | readonly U[],\n    thisArg?: This,\n  ): U[] {\n    return [...this].flatMap(callback, thisArg);\n  }\n  flat<A, D extends number = 1>(this: A, depth?: D): FlatArray<A, D>[];\n  flat<D extends number = 1>(depth?: D): FlatArray<this, D>[] {\n    throw new Error(\"Method not implemented.\");\n  }\n  at(index: number) {\n    return [...this].at(index);\n  }\n\n  [Symbol.iterator](): IterableIterator<T> {\n    return this.values();\n  }\n\n  // Other methods\n\n  description(): string {\n    throw new Error(\"Method not implemented.\");\n  }\n\n  /**\n   * Checks if this collection has not been deleted and is part of a valid Realm.\n   * @returns `true` if the collection can be safely accessed, `false` if not.\n   * @since 0.14.0\n   */\n  isValid(): boolean {\n    throw new Error(`Calling isValid on a ${this.constructor.name} is not support`);\n  }\n\n  /**\n   * Checks if this collection is empty.\n   * @returns `true` if the collection is empty, `false` if not.\n   * @since 2.7.0\n   */\n  isEmpty(): boolean {\n    return this.results.size() === 0;\n  }\n\n  /**\n   * Returns the minimum value of the values in the collection or of the\n   * given property among all the objects in the collection, or `undefined`\n   * if the collection is empty.\n   *\n   * Only supported for int, float, double and date properties. `null` values\n   * are ignored entirely by this method and will not be returned.\n   *\n   * @param property For a collection of objects, the property to take the minimum of.\n   * @throws {@link TypeAssertionError} If no property with the name exists or if property is not numeric/date.\n   * @returns The minimum value.\n   * @since 1.12.1\n   */\n  min(property?: string): number | Date | undefined {\n    const columnKey = this.getPropertyColumnKey(property);\n    const result = this.results.min(columnKey);\n    if (result instanceof Date || typeof result === \"number\" || typeof result === \"undefined\") {\n      return result;\n    } else if (typeof result === \"bigint\") {\n      return Number(result);\n    } else if (result instanceof binding.Float) {\n      return result.value;\n    } else if (result instanceof binding.Timestamp) {\n      return result.toDate();\n    } else {\n      throw new TypeAssertionError(\"Timestamp, number, bigint, Float or null\", result, \"result\");\n    }\n  }\n\n  /**\n   * Returns the maximum value of the values in the collection or of the\n   * given property among all the objects in the collection, or `undefined`\n   * if the collection is empty.\n   *\n   * Only supported for int, float, double and date properties. `null` values\n   * are ignored entirely by this method and will not be returned.\n   *\n   * @param property For a collection of objects, the property to take the maximum of.\n   * @throws {@link Error} If no property with the name exists or if property is not numeric/date.\n   * @returns The maximum value.\n   * @since 1.12.1\n   */\n  max(property?: string): number | Date | undefined {\n    const columnKey = this.getPropertyColumnKey(property);\n    const result = this.results.max(columnKey);\n    if (result instanceof Date || typeof result === \"number\" || typeof result === \"undefined\") {\n      return result;\n    } else if (typeof result === \"bigint\") {\n      return Number(result);\n    } else if (result instanceof binding.Float) {\n      return result.value;\n    } else if (result instanceof binding.Timestamp) {\n      return result.toDate();\n    } else {\n      throw new TypeAssertionError(\"Timestamp, number, bigint, Float or undefined\", result, \"result\");\n    }\n  }\n\n  /**\n   * Computes the sum of the values in the collection or of the given\n   * property among all the objects in the collection, or 0 if the collection\n   * is empty.\n   *\n   * Only supported for int, float and double properties. `null` values are\n   * ignored entirely by this method.\n   * @param property For a collection of objects, the property to take the sum of.\n   * @throws {@link Error} If no property with the name exists or if property is not numeric.\n   * @returns The sum.\n   * @since 1.12.1\n   */\n  sum(property?: string): number {\n    const columnKey = this.getPropertyColumnKey(property);\n    const result = this.results.sum(columnKey);\n    if (typeof result === \"number\") {\n      return result;\n    } else if (typeof result === \"bigint\") {\n      return Number(result);\n    } else if (result instanceof binding.Float) {\n      return result.value;\n    } else {\n      throw new TypeAssertionError(\"number, bigint or Float\", result, \"result\");\n    }\n  }\n\n  /**\n   * Computes the average of the values in the collection or of the given\n   * property among all the objects in the collection, or `undefined` if the collection\n   * is empty.\n   *\n   * Only supported for int, float and double properties. `null` values are\n   * ignored entirely by this method and will not be factored into the average.\n   * @param property For a collection of objects, the property to take the average of.\n   * @throws {@link Error} If no property with the name exists or if property is not numeric.\n   * @returns The sum.\n   * @since 1.12.1\n   */\n  avg(property?: string): number | undefined {\n    const columnKey = this.getPropertyColumnKey(property);\n    const result = this.results.average(columnKey);\n    if (typeof result === \"number\" || typeof result === \"undefined\") {\n      return result;\n    } else if (typeof result === \"bigint\") {\n      return Number(result);\n    } else if (result instanceof binding.Float) {\n      return result.value;\n    } else {\n      throw new TypeAssertionError(\"number, Float, bigint or undefined\", result, \"result\");\n    }\n  }\n\n  /**\n   * Returns new _Results_ that represent this collection being filtered by the provided query.\n   *\n   * @param query Query used to filter objects from the collection.\n   * @param arg Each subsequent argument is used by the placeholders\n   *   (e.g. `$0`, `$1`, `$2`, â€¦) in the query.\n   * @throws {@link Error} If the query or any other argument passed into this method is invalid.\n   * @returns Results filtered according to the provided query.\n   *\n   * This is currently only supported for collections of Realm Objects.\n   *\n   * @example\n   * let merlots = wines.filtered('variety == \"Merlot\" && vintage <= $0', maxYear);\n   */\n  filtered(queryString: string, ...args: unknown[]): Results<T> {\n    const { results: parent, realm, helpers } = this;\n    const kpMapping = binding.Helpers.getKeypathMapping(realm.internal);\n    const bindingArgs = args.map((arg) =>\n      Array.isArray(arg) ? arg.map((sub) => this.mixedToBinding(sub)) : this.mixedToBinding(arg),\n    );\n    const newQuery = parent.query.table.query(queryString, bindingArgs, kpMapping);\n    const results = binding.Helpers.resultsAppendQuery(parent, newQuery);\n    return new Results(realm, results, helpers);\n  }\n\n  /**\n   * Returns new _Results_ that represent a sorted view of this collection.\n   *\n   * A collection of Realm Objects can be sorted on one or more properties of\n   * those objects, or of properties of objects linked to by those objects.\n   * To sort by a single property, simply pass the name of that property to\n   * `sorted()`, optionally followed by a boolean indicating if the sort should be reversed.\n   * For more than one property, you must pass an array of\n   * **sort descriptors** which list\n   * which properties to sort on.\n   *\n   * Collections of other types sort on the values themselves rather than\n   * properties of the values, and so no property name or sort descriptors\n   * should be supplied.\n   * @param reverse Sort in descending order rather than ascended.\n   *   May not be supplied if `descriptor` is an array of sort descriptors.\n   * @throws {@link Error} If a specified property does not exist.\n   * @returns Results sorted according to the arguments passed in.\n   */\n  sorted(reverse?: boolean): Results<T>;\n  /**\n   * Returns new _Results_ that represent a sorted view of this collection.\n   *\n   * A collection of Realm Objects can be sorted on one or more properties of\n   * those objects, or of properties of objects linked to by those objects.\n   * To sort by a single property, simply pass the name of that property to\n   * `sorted()`, optionally followed by a boolean indicating if the sort should be reversed.\n   * For more than one property, you must pass an array of\n   * **sort descriptors** which list\n   * which properties to sort on.\n   *\n   * Collections of other types sort on the values themselves rather than\n   * properties of the values, and so no property name or sort descriptors\n   * should be supplied.\n   * @param descriptor The property name(s) to sort the collection on.\n   * @throws {@link Error} If a specified property does not exist.\n   * @returns Results sorted according to the arguments passed in.\n   */\n  sorted(descriptor: SortDescriptor[]): Results<T>;\n  /**\n   * Returns new _Results_ that represent a sorted view of this collection.\n   *\n   * A collection of Realm Objects can be sorted on one or more properties of\n   * those objects, or of properties of objects linked to by those objects.\n   * To sort by a single property, simply pass the name of that property to\n   * `sorted()`, optionally followed by a boolean indicating if the sort should be reversed.\n   * For more than one property, you must pass an array of\n   * **sort descriptors** which list\n   * which properties to sort on.\n   *\n   * Collections of other types sort on the values themselves rather than\n   * properties of the values, and so no property name or sort descriptors\n   * should be supplied.\n   * @param descriptor The property name(s) to sort the collection on.\n   * @throws {@link Error} If a specified property does not exist.\n   * @returns Results sorted according to the arguments passed in.\n   */\n  sorted(descriptor: string, reverse?: boolean): Results<T>;\n  sorted(arg0: boolean | SortDescriptor[] | string = \"self\", arg1?: boolean): Results<T> {\n    if (Array.isArray(arg0)) {\n      assert(typeof arg1 === \"undefined\", \"Second argument is not allowed if passed an array of sort descriptors\");\n      const { results: parent, realm, helpers } = this;\n      // Map optional \"reversed\" to \"accending\" (expected by the binding)\n      const descriptors = arg0.map<[string, boolean]>((arg) =>\n        typeof arg === \"string\" ? [arg, true] : [arg[0], !arg[1]],\n      );\n      // TODO: Call `parent.sort`, avoiding property name to colkey conversion to speed up performance here.\n      const results = parent.sortByNames(descriptors);\n      return new Results(realm, results, helpers);\n    } else if (typeof arg0 === \"string\") {\n      return this.sorted([[arg0, arg1 === true]]);\n    } else if (typeof arg0 === \"boolean\") {\n      return this.sorted([[\"self\", arg0]]);\n    } else {\n      throw new Error(\"Expected either a property name and optional bool or an array of descriptors\");\n    }\n  }\n\n  /**\n   * Create a frozen snapshot of the collection.\n   *\n   * Values added to and removed from the original collection will not be\n   * reflected in the _Results_ returned by this method, including if the\n   * values of properties are changed to make them match or not match any\n   * filters applied.\n   *\n   * This is **not** a _deep_ snapshot. Realm objects contained in this\n   * snapshot will continue to update as changes are made to them, and if\n   * they are deleted from the Realm they will be replaced by `null` at the\n   * respective indices.\n   *\n   * @returns Results which will **not** live update.\n   */\n  snapshot(): Results<T> {\n    return new Results(this.realm, this.results.snapshot(), this.helpers);\n  }\n\n  private getPropertyColumnKey(name: string | undefined): binding.ColKey {\n    if (this.classHelpers) {\n      assert.string(name, \"name\");\n      return this.classHelpers.properties.get(name).columnKey;\n    } else if (name) {\n      throw new Error(`Cannot get property named '${name}' on a list of primitives`);\n    } else {\n      return DEFAULT_COLUMN_KEY;\n    }\n  }\n}\n"]}